/* Otway and Ree's key exchange protocol */

/* Message 1: A->B  A,B,NonceA */
/* Message 2: B->S  A,B,NonceA,NonceB */
/* Event 1: S begins <A,B,KeyAB> */
/* Event 2: S begins <B,A,KeyAB> */
/* Message 3: S->B  {msg4(A,B,KeyAB,NonceA)}KeyAS,{msg3(A,B,KeyAB,NonceB)}KeyBS */
/* Event 3: B ends <B,A,KeyAB> */
/* Message 4: B->A  {msg4(A,B,KeyAB,NonceA)}KeyAS */
/* Event 4: A ends <A,B,KeyAB> */

(news db)
(news sender)
(news receiver)
(
 /*** server ***/
 (*net?msg4.
   split msg4 is (a,msg42).
   split msg42 is (b,msg43).
   split msg43 is (nonA,nonB).
   (new keyAB)
   begin (a,(b,keyAB)).
   begin (b,(a,keyAB)).
   db??x.
   match x is (a, keyAS).
   db??y.
   match y is (b, keyBS).
   net!({inl((a,(b,(keyAB,nonA))))}keyAS,{inr((a,(b,(keyAB,nonB))))}keyBS))
|
 (*sender??x.  /*** sender ***/
   split x is (a, keyA).
   net?b.
   (new non)
   (net!(a,(b,non))
   |net?y.
    decrypt y is {m4}keyA.
    case m4 is inl(m4b).
                (match m4b is (a, m42).
                 match m42 is (b, m43).
                 split m43 is (keyAB, non2).
                check non is non2.
                end (a,(b,keyAB)).O)
             is inr(dummy).O))
|
 (*receiver??x.  /*** receiver ***/
   split x is (b, keyB).
   net?msg3.
   split msg3 is (a,msg32).
   match msg32 is (b,nonA).
   (new nonB)
   (net!(a,(b,(nonA,nonB)))
   |net?ct.
    split ct is (ctxa,ctxb).
    decrypt ctxb is {m3}keyB.
    case m3 is inl(dm1).O
     is inr(m3b).
         match m3b is (a, m3b2).
         match m3b2 is (b, m3b3).
         split m3b3 is (keyABb, nonB2).
         check nonB is nonB2.
         end (b,(a,keyABb)).
         net!ctxa))
|*(new p)(new keyP)  /*** infinitely participants of the protocol ***/
   (*net!p |
    *db!!(p,keyP) | 
    *sender!!(p,keyP) | 
    *receiver!!(p, keyP))
)

